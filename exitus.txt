#################################################### 1 ########################################################

# Docuemntacion -----------------------------------------------------------
"
MODELO PARA PRONOSTICAR LA COBRANZA DE LOS 4 PORTAFOLIOS DE BBVA

El entrenamiento se hizo con abril, mayo y junio para pronosticar la cobranza en julio y
agosto (en dias) y contemplar intervalos de confianza del 95% para cada
pronostico puntual.
El ajuste es una regresion multilineal con variables numericas y categoricas.

@version  : 1.2
@author   : Aaron Lopez Pedraza
@date     : 06-07-2021
@update 1 : 09-07-2021
@update 2 : 19-07-2021
@update 3 : 23-07-2021
@update 4 : 26-07-2021


@update 1:
Se optimizo el codigo, adhesion de la funcion 'install_or_load_pack()'

@update 2:
Anadimos a este codigo las predicciones de para Julio del portafolio bbva3  

@update 3:
Refinamos el proceso de pronostico, automatizamos algunos procesos y corregimos algunos
errores

@update 4:
Cambio de seleccion de dias aleatorios de compartamiento en la cobranza por un promedio de
cada dia de los tres meses de entrenamiento y la automatizacion de la agregacion de los
montos (doble for) y se debe quitar como predictor la 'QUITA'.

MODELO PREDICTIVO DE COBRANZA version 1
Construimos el modelo a traves de una regersion lineal multiple, las variables (predictores):
  
Y~ = 'Cobranza'(variable a pronosticar):  El monto de la cobranza
X1 = 'PRODUCTO'                        :  Si es AUTO, CONSUMO, etc. (categorica)
X2 = 'CONVENIO_LIQUIDO_PAGO_INTENCION' :  Si hay convenio, pago intencion, etc. (categorica)
X3 = 'PAGO_NO'                         :  # de pagos registrados en el ultimo 
                                            convenio vigente en ese credito. (numerica)
X4 = 'QUITA'(en el update 4 se elimina):  Para un convenio, el % de la tasa de descuento,
                                          etc. (numerica)                                     
"
# BIBLIOTECAS Y DICCIONARIO DE DATOS -------------------------------------------------------------
##### bibliotecas ####

"funcion para instalar, ver si estan instaladas o mandar a llamar bibliotecas, a la funcion
se le debe pasar un vector de blibiotecas.
"
install_or_load_pack <- function(pack){
  
  create.pkg <- pack[!(pack %in% installed.packages()[, "Package"])]
  
  if (length(create.pkg))
    
    install.packages(create.pkg, dependencies = TRUE)
  
  sapply(pack, require, character.only = TRUE)
  
}
#vemos si estan instaladas las bibliotecas, las instalamos o mandamos a llamar
install_or_load_pack(c("readxl","openxlsx","dplyr","ggplot2","data.table",
                       "caret","scales","Rcpp"))

# MODELO PARA BBVA3 -------------------------------------------------------------------
getwd()
setwd(x<-choose.dir())
#setwd("C:\\Users\\aaron.lopez\\Documents\\R_Scripts\\Modelo predictivo bbva3")
# dir()#observamos los archivos que hay rn nuestro directorio de trabajo:

pagos.julio <- read.xlsx("Pagos Julio.xlsx",sheet ="Hoja1",detectDates = TRUE)

##### ananlisis exploratorio ####
# View(pagos.julio);names(pagos.julio);dim(pagos.julio)#13713    33
str(pagos.julio)#observamos los campos del dataset

"PENDIENTE: Hacer los castings y renombrar las variables (por los acentos)
para su adecuada manipulacion:
1.-CRÃDITO --------------------------> CREDITO
2.-#.PAGOS --------------------------> PAGO_NO
3.-CONVENIO,.LIQUIDO,PAGO.INTENCIÃN -> CONVENIO_LIQUIDO_PAGO_INTENCION 
4.-Fecha.Pago -----------------------> Fecha_Pago
5.-factor(PRODUCTO)
6.-factor(CONVENIO_LIQUIDO_PAGO_INTENCION)
7.-Recalcular la QUITA (para una version posterior del modelo)
8.-Quitar los autopagos
"
##### renombramos columnas ####
colnames(pagos.julio)[3] <- "CREDITO"
colnames(pagos.julio)[7] <- "Fecha_Pago"
colnames(pagos.julio)[22] <- "CONVENIO_LIQUIDO_PAGO_INTENCION"
colnames(pagos.julio)[25] <- "PAGO_NO"
#validamos:
names(pagos.julio)#ok, cambios exitosos

##### columnas ####
#conservamos solo las columnas que ocuparemos para cargar menos informacion en el dataset:
pagos.julio <- pagos.julio[,c(3,6,7,9,12,17,22,25,26)]
#View(pagos.julio);dim(pagos.julio)#13713     9

##### meses y portafolios ####
#observamos y seleccionamos los portafolios para los meses de entrenamiento
table(pagos.julio$MES);table(pagos.julio$CARTERA)
#seleccionamos los meses para el portafolio bbva3
pagos.julio <- filter(pagos.julio,(MES=="ABRIL 2021"|MES=="MAYO 2021"|MES=="JUNIO 2021")&
                        (CARTERA=="BBVA III"))

#dim(pagos.julio)#796   9

#veamos el rango de fechas para validar que no traemos pagos de otros meses:
range(pagos.julio$Fecha_Pago)#tenemos pagos con fechas del 31 de Marzo 2021 en adelante  
sum(pagos.julio$Fecha_Pago<"2021-04-01")#en particular tenenos 3 pagos de marzo
filter(pagos.julio,Fecha_Pago<"2021-04-01")#observamos los pagos

"Comenzamos a limpiar y preprocesar los predictores, es decir ctaegorias correctas, que
no hay na's, que sean tipos de datos correctos; asi como quitar los autopagos.
"
##### tipos de datos (categoricas y numericas) ####
#PRODUCTO
#este es el pendiente 5.- de nuestras variables como input del modelo:
table(pagos.julio$PRODUCTO)#no hay NA's
class(pagos.julio$PRODUCTO)#hay que transformarlas en tipos de datos
#en caso de que haya tipos de pagos sin categoria:  
pagos.julio$PRODUCTO[is.na(pagos.julio$PRODUCTO)] <- "SIN IDENTIFICAR"

#Ahora si ya pasamos a variable tipo factor porque las categorias son consistentes:
pagos.julio$PRODUCTO <- as.factor(pagos.julio$PRODUCTO)#ok

#QUITA
"NOTA:
En una version posterior, se deben recalcuar adecuadamente la QUITA porque en el reporte
historico de pagos, hay algunas inconsistencias de este calculo.
"
class(pagos.julio$QUITA)#numeric, ok
table(pagos.julio$QUITA)#hay que redondear las quitas
pagos.julio$QUITA <- round(x = pagos.julio$QUITA,digits = 2)
pagos.julio$QUITA <- ifelse(pagos.julio$QUITA<0,0,pagos.julio$QUITA)#ok
#validamos:
table(pagos.julio$QUITA)#hay que redondear las quitas

#TIPOS DE PAGOS:
"
IMPORTANTE:
En los tipos de pagos, para quitar los AUTOPAGOS, estos se encuentran en la variable
'CONVENIO_LIQUIDO_PAGO_INTENCION' la categoria 'TRASPASO DE FLUJOS', entonces filtramos esa
variable.

Para el tratamiento de esta variable, primero se corrige el texto y luego se pasa a factor,
 ya que si no se hace asi, a la variable PRODUCTO(factos) se le tendria que crear un nuevo
 nivel; por esta razon decidi corregir primero en texto los NA's y finalmente pasar
 la variable PRODUCTO a factor; recordemos que esta variable debe ser factor porque asi se
 determino en el modelo como predictor.
"
class(pagos.julio$CONVENIO_LIQUIDO_PAGO_INTENCION)#ok
table(pagos.julio$CONVENIO_LIQUIDO_PAGO_INTENCION)
#en caso de que haya tipos de pgos == "0"
pagos.julio$CONVENIO_LIQUIDO_PAGO_INTENCION[pagos.julio$CONVENIO_LIQUIDO_PAGO_INTENCION=="0"] <- "SIN IDENTIFICAR"
#en caso de que haya tipos de pgos == NA
pagos.julio$CONVENIO_LIQUIDO_PAGO_INTENCION[is.na(pagos.julio$CONVENIO_LIQUIDO_PAGO_INTENCION)] <- "NO APLICA"
#transformamos finalmente en factor a la variable:
pagos.julio$CONVENIO_LIQUIDO_PAGO_INTENCION <- as.factor(pagos.julio$CONVENIO_LIQUIDO_PAGO_INTENCION)
#validamos:
#str(pagos.julio$CONVENIO_LIQUIDO_PAGO_INTENCION)
class(pagos.julio$CONVENIO_LIQUIDO_PAGO_INTENCION)
#summary(pagos.julio$CONVENIO_LIQUIDO_PAGO_INTENCION)#ok

#PAGOS
class(pagos.julio$PAGO_NO)#numeric, ok
table(pagos.julio$PAGO_NO)#ok, ,todo en orden

##### na's  ####
#aqui vamos a eliminar todos lo NA's y para ello primero los vamos a contar:
#PRODUCTO
sum(is.na(pagos.julio$PRODUCTO))#0,ok

#QUITA
sum(is.na(pagos.julio$QUITA))#0, ok
#en caso de que hubiera na's:
pagos.julio$QUITA[is.na(pagos.julio$QUITA)] <- 0
#validamos:
sum(is.na(pagos.julio$QUITA))#0, ok

"para eliminar los NA's de la varible 'Pago Convenio', trabaje primero esto en texto y luego ya se 
pasa como factor, de lo contrario hay que crear un nuevo nivel; por esta razon corregii los NA's en la
 seccion 'tipos de datos'
"
#TIPOS DE PAGOS:
sum(is.na(pagos.julio$CONVENIO_LIQUIDO_PAGO_INTENCION))#0, ok

#NUMERO DE PAGOS:
sum(is.na(pagos.julio$PAGO_NO))#0, ok

#ok, ya no hay datos faltantes

##### quitamos los auto pagos ####
"
IMPORTANTE:
En los tipos de pagos, para quitar los AUTOPAGOS, estos se encuentran en la variable
'CONVENIO_LIQUIDO_PAGO_INTENCION' la categoria 'TRASPASO DE FLUJOS', entonces filtramos esa
variable.
"
hist(pagos.julio$Cobranza,breaks = 200)#Tenemos una distribucion de cola pesada

#validamos que no haya pagos 'CONVENIO_LIQUIDO_PAGO_INTENCION' - 'TRASPASO DE FLUJOS'
table(pagos.julio$CONVENIO_LIQUIDO_PAGO_INTENCION)#ok, no hay

#los contamos y visualizamos
dim(select(pagos.julio,Cobranza) %>% filter(Cobranza<=100) %>% arrange(Cobranza))#6 pagos<=$100
#Vemos los pagos<=$100
View(select(pagos.julio,Cobranza) %>% filter(Cobranza<=100) %>% arrange(Cobranza))
#View(select(pagos.julio,Cobranza) %>% filter(Cobranza>100) %>% arrange(Cobranza))

#Aun cuando no hay pagos tipo 'TRASPASO DE FLUJOS' , quitamos los pagos menores a $100

pagos.julio <- filter(pagos.julio,Cobranza>100)#ok
min(pagos.julio$Cobranza)#validamos, ok

##### entrenamiento del modelo #####
#SIN LA QUITA:
mp.bbva3 <- lm(Cobranza ~ PRODUCTO + CONVENIO_LIQUIDO_PAGO_INTENCION + PAGO_NO,
               data = pagos.julio )

y<-summary(mp.bbva3)#detalle del modelo ajustado
"
Anterior summary (contemplando QUITA)
Call:
lm(formula = Cobranza ~ PRODUCTO + CONVENIO_LIQUIDO_PAGO_INTENCION + 
    PAGO_NO + QUITA, data = pagos.julio)

Residuals:
   Min     1Q Median     3Q    Max 
-18020  -3679  -1431    976 119216 

Coefficients:
                                               Estimate Std. Error t value Pr(>|t|)    
(Intercept)                                     13233.8     2083.5   6.352 3.61e-10 ***
PRODUCTOCONSUMO                                 -4077.7     1786.7  -2.282 0.022744 *  
PRODUCTOTDC BANCARIA                            -4565.5     1770.4  -2.579 0.010097 *  
PRODUCTOTDC FINANZIA                            -8409.1     2115.6  -3.975 7.70e-05 ***
CONVENIO_LIQUIDO_PAGO_INTENCIONCONVENIO          8694.0     7071.3   1.229 0.219265    
CONVENIO_LIQUIDO_PAGO_INTENCIONLIQUIDO           6604.3      881.5   7.492 1.85e-13 ***
CONVENIO_LIQUIDO_PAGO_INTENCIONNO APLICA         -396.9     1355.2  -0.293 0.769700    
CONVENIO_LIQUIDO_PAGO_INTENCIONPAGO INTENCIÃN     289.8     1410.4   0.205 0.837271    
CONVENIO_LIQUIDO_PAGO_INTENCIONSIN IDENTIFICAR   -954.1     9913.6  -0.096 0.923352    
PAGO_NO                                          -440.9      128.9  -3.419 0.000660 ***
QUITA                                           -5273.3     1481.0  -3.561 0.000392 ***
---
Signif. codes:  0 â***â 0.001 â**â 0.01 â*â 0.05 â.â 0.1 â â 1

Residual standard error: 9870 on 779 degrees of freedom
Multiple R-squared:  0.1563,	Adjusted R-squared:  0.1455 
F-statistic: 14.43 on 10 and 779 DF,  p-value: < 2.2e-16
"
confint(mp.bbva3)#intervalo de confianza para los coeficientes 

##### construccion del dataset input modelo bbva3 ####
"aqui se debe de construir el dataset que servira como input de las predicciones, es decir;
para cada predictor, determinar el valor esperado de elementos tanto cualitativa y
cuantitativamente, es decir, el numero de PRODUCTO, CONVENIO_LIQUIDO_PAGO_INTENCION,
PAGO_NO y QUITA.

La estrategia para hacer esto es anadir el dia (distinguible de cada mes) al dataset
'pagos.julio', concatenar el dia (en numero) con la primera letra del mes
al que corresponde, ejemplo, '28-J' (28 de Julio), despues tomar el comportamiento de 30
dias (10 por mes) para el comportamiento general del pronostico.
"

#promedio de la cantidad de valores para input ####
"Aqui se debe calcular un promedio de los valores esperados para el numero de pagos y para
cada predictor (PRODUCTO,CONVENIO_LIQUIDO_PAGO_INTENCION y PAGO_NO) con respecto al periodo
de tiempo de entrenamiento del modelo Abril-Junio.
"
#NUMERO DE PAGOS:
pagos.por.mes <- round(length(pagos.julio$CREDITO)/3,digits = 0)

# PRODUCTO:
prod <- as.data.frame(round(table(pagos.julio$PRODUCTO)/3,digits = 0))
#round(table(pagos.julio$PRODUCTO)/3,digits = 0)

#TIPO DE PAGO:
pag <- as.data.frame(round(table(pagos.julio$CONVENIO_LIQUIDO_PAGO_INTENCION)/3,digits = 0))
#round(table(pagos.julio$CONVENIO_LIQUIDO_PAGO_INTENCION)/3,digits = 0)

#NUMERO DE PAGOS:
num <- round(table(pagos.julio$PAGO_NO)/3,digits = 0)
#round(table(pagos.julio$PAGO_NO)/3,digits = 0)

#creamos un dataframe para sumar las predicciones e intervalos para los 31 dias de julio21
input.pronos <- data.frame("PRODUCTO"=rep(NA,round(length(pagos.julio$CREDITO)/3,digits = 0)),
                           "CONVENIO_LIQUIDO_PAGO_INTENCION"=rep(NA,round(length(pagos.julio$CREDITO)/3,digits = 0)),
                           "PAGO_NO"=rep(NA,round(length(pagos.julio$CREDITO)/3,digits = 0)))

# install.packages("gtools")
# library(gtools)
# unique(pagos.julio$PRODUCTO)
# class(unique(pagos.julio$PRODUCTO))
# as.vector(unique(pagos.julio$PRODUCTO))
# 
# combinations(round(length(pagos.julio$CREDITO)/3,digits=0),
#              1,as.vector(unique(pagos.julio$PRODUCTO)))
# 
# sample(x = as.vector(unique(pagos.julio$PRODUCTO)),
#        size =round(length(pagos.julio$CREDITO)/3,digits=0),replace = T )
# 
# ?combinations

"llenamos el dataset de inputs:
creamos los vectores de inouts, del tamanio del numero de pagos estimado oara julio,
preservando la proporcion de cada categoria y finalemnete barajeando los vectores.
"
#PRODUCTOS:
prod <- as.data.frame(round(table(pagos.julio$PRODUCTO)/3,digits = 0))
prods <-as.factor(c(rep("AUTO",prod$Freq[1]),rep("CONSUMO",prod$Freq[2]),
                    rep("TDC BANCARIA",prod$Freq[3]),rep("TDC FINANZIA",prod$Freq[4])))
prods <-sample(x = prods ,size = round(length(pagos.julio$CREDITO)/3,digits = 0),replace = F)
input.pronos$PRODUCTO <- prods

#TIPOS DE PAGO:
pag <- as.data.frame(round(table(pagos.julio$CONVENIO_LIQUIDO_PAGO_INTENCION)/3,digits = 0))
pag$Var1 <- as.character(pag$Var1)
pag$Freq <- as.character(pag$Freq)
pags <-as.factor(c(rep(pag$Var1[1],pag$Freq[1]),rep(pag$Var1[2],pag$Freq[2]),
                   rep(pag$Var1[3],pag$Freq[3]),rep(pag$Var1[4],pag$Freq[4]),
                   rep(pag$Var1[5],pag$Freq[5]),rep(pag$Var1[6],pag$Freq[6])))

pags <-sample(x = pags ,size = round(length(pagos.julio$CREDITO)/3,digits = 0),replace = F)
#llenamos el dataset:
input.pronos$CONVENIO_LIQUIDO_PAGO_INTENCION <- pags

#NUMERO DE PAGOS:
num <- as.data.frame(round(table(pagos.julio$PAGO_NO)/3,digits = 0))
num$Var1 <- as.character(num$Var1)
num$Freq <- as.character(num$Freq)
nump <-as.numeric(c(rep(num$Var1[1],num$Freq[1]),rep(num$Var1[2],num$Freq[2]),
                    rep(num$Var1[3],num$Freq[3]),rep(num$Var1[4],num$Freq[4]),
                    rep(num$Var1[5],num$Freq[5]),rep(num$Var1[6],num$Freq[6]),
                    rep(num$Var1[7],num$Freq[7]),rep(num$Var1[8],num$Freq[8]),
                    rep(num$Var1[9],num$Freq[9]),rep(num$Var1[10],num$Freq[10]),
                    rep(num$Var1[10],num$Freq[10]),rep(num$Var1[12],num$Freq[12]),
                    rep(num$Var1[13],num$Freq[13])))

nump <-sample(x = nump ,size = round(length(pagos.julio$CREDITO)/3,digits = 0),replace = F)
input.pronos$PAGO_NO <- nump

#ya tenemos llenos el input del pronostico lleno

##### predecciones julio bbva3 ####
predicciones.julio.bbva3 <- predict(mp.bbva3,newdata = input.pronos,
                                    interval = "confidence",level = 0.95)

#observaciones a agregar por frecuencia de pagos x dia
predicciones.julio.bbva3.df <- as.data.frame(predicciones.julio.bbva3)#PREDICCIONES

#quitamos valores negativos:
predicciones.julio.bbva3.df$fit <- ifelse(predicciones.julio.bbva3.df$fit<0,0,predicciones.julio.bbva3.df$fit)
predicciones.julio.bbva3.df$lwr <- ifelse(predicciones.julio.bbva3.df$lwr<0,0,predicciones.julio.bbva3.df$lwr)
predicciones.julio.bbva3.df$upr <- ifelse(predicciones.julio.bbva3.df$upr<0,0,predicciones.julio.bbva3.df$upr)
#ok

#creamos un dataframe para sumar las predicciones e intervalos para los 31 dias de julio21
pronostico <- data.frame("julio"=1:31,"inferior"=rep(0,31),
                         "puntual"=rep(0,31),"superior"=rep(0,31))

#contamos el numero de pagos que tendra cada dia del pronostico para agrupar:
pagos.por.dia <- data.frame("dia"=1:31,"num.pagos"=rep(0,31))

#construimos la variable y concatenamos:
pagos.julio$dia <- format(pagos.julio$Fecha_Pago,format = "%d")
table(pagos.julio$dia)#todo en orden

d <- c("01","02","03","04","05","06","07","08","09","10","11","12","13",
       "14","15","16","17","18","19","20","21","22","23","24","25","26","27",
       "28","29","30","31")

#llenamos el dataset con con el numero de pagos que hubo por cada dia:
for (i in 1:31) {
  pagos.por.dia$num.pagos[i] <-  round(sum(pagos.julio$dia == d[i])/3,0)
}

#agregamos los pronosticos por dia al dataset de pronostico:
j=1
for (i in 1:31) {
  j2=1
  while(j2<=pagos.por.dia$num.pagos[i] ){
    pronostico$inferior[i] = pronostico$inferior[i]+predicciones.julio.bbva3.df$lwr[j]
    pronostico$puntual[i] = pronostico$puntual[i]+predicciones.julio.bbva3.df$fit[j]
    pronostico$superior[i] = pronostico$superior[i]+predicciones.julio.bbva3.df$upr[j]
    j=j+1
    j2=j2+1
  }
  if(pagos.por.dia$num.pagos[i]==0){
    pronostico$superior[4] <- abs(sd(predicciones.julio.bbva3.df$fit))
  }
}

#pronostico diario para bbva3 julio 2021:
pronostico

cobranza.esperada <- data.frame("inferior"=dollar(sum(pronostico$inferior),big.mark = ",",decimal.mark = "."),
                                "puntual"=dollar(sum(pronostico$puntual),big.mark = ",",decimal.mark = "."),
                                "superior"=dollar(sum(pronostico$superior),big.mark = ",",decimal.mark = "."))

##### la garfica de las predicciones #####
grafica.pronostico.cobranza.bbva3.julio <- ggplot(data = pronostico,
                                                  aes(x = julio, y = puntual)) +
  geom_point(col = "darkgrey") +
  geom_smooth(method = "lm", formula = y ~ poly(x, 6), color = "blue", se = TRUE, 
              level = 0.95) +
  labs(title = "Pronostico de la cobranza en BBVA3",
       x="dias",y="$",caption = "Del 1-31 julio") +
  theme_bw() + theme(plot.title = element_text(hjust = 0.5));grafica.pronostico.cobranza.bbva3.julio


##### exportamos resultados ####
#pronostico bbva3 para julio 2021
getwd()#"C:/Users/aaron.lopez/Documents/R_Scripts/Modelo predictivo bbva3"
export(pronostico,"predicciones_bbva3_julio21_vf.xlsx")#se exportan al directorio de trabajo




#################################################### 2 ########################################################

"
codigo que segmenta a traves de 'k-means' los portafolios de bbva considerando su contacto
y respuesta ante los masivos de sms, blaster, rcs y correos electronicos
durante abril, mayo y junio 2021.

@version  : 1.0
@author   : Aaron Lopez Pedraza
@date     : 14-07-2021
@update 1 : 16-07-2021

"
# BIBLIOTECAS, DICCIONARIO DE DATOS Y DATOS-------------------------------------------------------------
##### bibliotecas ####
library(readxl)
library(openxlsx)
library(dplyr)
library(ggplot2)
library(data.table)
library(caret)
library(rio)
library(tidyverse)
library(data.table)
library(skimr)
library(scales)
library(NbClust)
library(cluster)
library(readr)
library(lubridate)
library(expss)

##### diccionario ####
"
sms              = reporte de sms en bbva para abril, mayo y junio
campos.sms       = campos y los tipos de datos del reporte de sms
b1               = parte 1 del reporte de blasters
campos.blasters1 = campos y los tipos de datos de la parte 1 del reporte de blasters
c                = cuentas del portafolio bbva para ser segmentadas
b2               = cuentas unicas con conteo de activida de blasters

"

getwd()#anterior: "C:/Users/aaron.lopez/Documents/R_Scripts/Modelo predictivo bbva1 y bbva2"
choose.dir()
setwd("C:\\Users\\aaron.lopez\\Documents\\Bases\\Segmentacion_con_medios_masivos");dir()


##### DATOS ####
#RFC's, c=cuentas
dir()
#e lo ocupamos solo para leer las cuentas:
e <-read_csv("Base BBVA Limpia (1).csv",col_names = TRUE,
             col_types = cols_only(IDPRINCIPAL = col_character()))
#View(e)
#c es para leer los demas campos
c <-read_csv("Base BBVA Limpia (1) - copia.csv",col_names = TRUE,
             col_types = cols_only(IDPRINCIPAL = col_character(),
                                   RFC = col_character(),HOMOCLAVE_RFC = col_character(),
                                   PRIMER_NOMBRE = col_character(),
                                   SEGUNDO_NOMBRE = col_character(),
                                   APELLIDO_PATERNO = col_character(),
                                   APELLIDO_MATERNO = col_character(),
                                   CODIGO_POSTAL = col_character(),
                                   ENTIDAD_FEDERATIVA = col_character(),
                                   MUNICIPIO_ALCALDIA = col_character(),
                                   COLONIA = col_character(),EDAD = col_character(),
                                   RANGO_EDAD = col_character(),
                                   SALDO_TOTAL = col_character(),
                                   RANGO_DEUDA = col_character(),
                                   PRODUCTO = col_character()))

names(c);class(c$IDPRINCIPAL)
dim(c);dim(e)
view(c);names(c)

"Por alguna extrania razon, no lee adecuadamente como texto el IDPRINCIPAL del objeto 'c'
entonces como del objeto 'd' si lo lee bien, reemplazamos y listo,
a continuacion la prueba de ello, veamos una muestra de los primeros 3 registros.

"
#aqui la razon del porque se cruzan ambos archivos:
c$IDPRINCIPAL[1:3]#"7.41E+17" "7.45E+17" "7.44E+17"
e$IDPRINCIPAL[1:3]#"00740960509660484755" "00744769889826712781" "00744448609649506446"

#para su correcta lectura de las IDPRICIPALES, reemplazamos el id
c$IDPRINCIPAL <- e$IDPRINCIPAL
remove(e)#eliminamos el bojeto 'e'
View(c, title = "CUENTAS a segmentar");dim(c)#528123

#quitar los RFC's que tengan los 'XXX', es decir rfcs invalidos
c <- c[-(which(startsWith(c$RFC,"XEX"))),]
dim(c)#528033, se filtraron 90 cts. Trabajar con c


##### blasters parte 1 #####
"b1= parte 1 del reporte de blasters
rango de fechas en este reporte : 2020-04-01 - 2020-06-29
"
dir()#enlista los archivos que hay en el directorio de trabajo
#b1= parte 1 del reporte de blasters
b1 <- read.csv("Reporte Blasters.csv")

#campos y sus tipos de datos
campos.blasters1 <- data.frame("Campo"=rep(NA,length(names(b1))),
                               "Tipo.de.dato"=rep(NA,length(names(b1))))

#llenamos el dataframe con los campos y sus tipos de datos:
for (nombre in 1:nrow(campos.blasters1)) {
  campos.blasters1$Campo[nombre] <- names(b1)[nombre]
  campos.blasters1$Tipo.de.dato[nombre] <- class(names(b1)[nombre])   
}
campos.blasters1#lo visualizamos
#o predeterminandamente:
str(b1)

#filtramos para los portafolios adecuados:
dim(b1);unique(b1$cartera2)#16822946       20
dim(b1)#13178302       20

b1 <- filter(b1,cartera2=='BBVA I'|cartera2=='BBVA II'|
               cartera2=='BBVA III'|cartera2=='BBVA IV')

b1$fe_bien[1:2]#veamos una muestra
b1$fe_bien <- as.Date(b1$fe_bien,format = "%m/%d/%y")
class(b1$fe_bien);head(b1,n = 3)#ok, ya el formato adecuado
b1$MES <- months(b1$fe_bien)#creamos una variable nueva
table(b1$MES)#trae 'abril', 'mayo' y 'junio'
#veamos el rango:
summary(b1$fe_bien)
"
      Min.      1st Qu.       Median         Mean      3rd Qu.         Max.       NA's 
  2020-04-01   2020-04-15   2020-04-27    2020-04-27  2020-05-04     2020-06-29    231
"

names(b1)
nrow(b1);nrow(b1.prueba)
b1 <- b1[-which(is.na(b1$fe_bien)),]#quitamos los nas en las fechas (231)

#View(b1, title = "BLASTERS, data original")

"CRITERIO de contacto exitoso - no exitos:
anadimos la clasificacion de exito-no exito en el envio del masivo al dataset,
verificar el catalogo de exito:
"
#CLASIFICACION_DE_EXITO blasters
vcn <- c("BUZON","BUZON DE VOZ","FUERA DE SERVICIO, SUSPENDIDA",
         "MARCADOR GENESYS","NO CONTESTA","NO CONTESTADA",
         "NO ENLAZA-NO EXISTE","NO EXISTE","NO EXITOSO","OCUPADO",
         "SIN AUDIO","SIN INTERACION")

clasificacion.blasters <- as.data.frame(table(b1$resultado))
#View(clasificacion.blasters)

b1 <- mutate(b1,CLASIFICACION_EXITO=ifelse(CRITERIO %in% vcn,
                                         "No Exitosa", "Exitosa"))
table(b1$CLASIFICACION_EXITO)

# sort(unique(b1$CRITERIO))
# table(b1$CRITERIO)
# sort(table(b1$CRITERIO))

##### blasters parte 2 ####
"b2= parte 2 del reporte de blasters
rango de fechas en este reporte : 
"
b2 <- read.csv("Reporte Blasters Parte 2.csv")


##### blasters parte 3 ####
"b3= parte 3 del reporte de blasters
rango de fechas en este reporte : 
"
b3 <- read.csv("Reporte Blasters Parte 3.csv")


##### sms ####
"sms= reporte de sms
rango de fechas en este reporte : 
"
dir()
sms <- read.csv("Reporte SMS.csv");dim(sms);head(sms,n = 3)# 7976109, 19 (original)

#campos y sus tipos
campos.sms <- data.frame("Campo"=rep(NA,length(names(sms))),
                         "Tipo.de.dato"=rep(NA,length(names(sms))))
#campos.sms

#llenamos el dataframe con los campos y sus tipos de datos:
for (nombre in 1:nrow(campos.sms)) {
  #cat(nombre,".-",names(sms.prueba)[nombre],"-",class(names(sms.prueba)[nombre]),"; ")
  
  campos.sms$Campo[nombre] <- names(sms)[nombre]
  campos.sms$Tipo.de.dato[nombre] <- class(names(sms)[nombre])   
}
campos.sms#lo visualizamos

sms <- filter(sms,cartera2=='BBVA I'|cartera2=='BBVA II'|
               cartera2=='BBVA III'|cartera2=='BBVA IV')

b1$fe_bien[1:2]#veamos una muestra
b1$fe_bien <- as.Date(b1$fe_bien,format = "%m/%d/%y")
class(b1$fe_bien);head(b1,n = 3)#ok, ya el formato adecuado
b1$MES <- months(b1$fe_bien)#creamos una variable nueva
table(b1$MES)#trae 'abril', 'mayo' y 'junio'
#veamos el rango:
summary(b1$fe_bien)
"
      Min.      1st Qu.       Median         Mean      3rd Qu.         Max.       NA's 
  2020-04-01   2020-04-15   2020-04-27    2020-04-27  2020-05-04     2020-06-29    231
"

names(b1)
nrow(b1);nrow(b1.prueba)
b1 <- b1[-which(is.na(b1$fe_bien)),]#quitamos los nas en las fechas (231)

#View(b1, title = "BLASTERS, data original")

"CRITERIO de contacto exitoso - no exitos:
anadimos la clasificacion de exito-no exito en el envio del masivo al dataset,
verificar el catalogo de exito:
"
#anadimos el mes a la variable MES en el dataset
clasificacion.sms <- as.data.frame(table(sms$resultado))
#View(clasificacion.blasters)

vcn_sms <- c("CANCELADA","ENVIADO","ERROR","INVALIDO","PAUSADA")

sms <- mutate(sms,CLASIFICACION_EXITO=ifelse(CRITERIO %in% vcn_sms,
                                         "No Exitosa", "Exitosa"))

table(sms$resultado)

# sort(unique(b1$CRITERIO))
# table(b1$CRITERIO)
# sort(table(b1$CRITERIO))




# ENVIO Y RESPUESTA DE MASIVOS --------------------------------------------
##### blasters  ####
b1.1 <-  b1 %>%#BLASTERS
  select(cuenta,CLASIFICACION_EXITO) %>% 
  group_by(cuenta) %>% 
  summarize(BLASTERS_ENVIADOS = n(),
            BLASTERS_EXITOS = sum(CLASIFICACION_EXITO=="Exitosa"),
            BLASTER_CONTACTO=ifelse(BLASTERS_EXITOS==0,0,1))#bandera de si lo contacte o no
View(b1.1,title = "blaster x cta abr-mayo bbva")
dim(b1.1)

##### sms  ####
sms1 <-  sms %>%#SMS
  select(CUENTAS,CLASIFICACION_EXITO) %>% 
  group_by(CUENTAS) %>% 
  summarize(SMS_ENVIADOS = n(),
            SMS_EXITOS = sum(CLASIFICACION_EXITO=="Exitosa"),
            SMS_CONTACTO=ifelse(SMS_EXITOS==0,0,1))
View(sms1,title = "sms x cta abr-mayo bbva")
dim(sms1)


##### IGUALDAD DE LLAVES ####
#comprobamos que la llave de cruze se llame igual: "IDPRICIPAL"
names(b1.1);names(b1.1);names(c)
#names(b1.1)[1] <- names(c)[1]
#names(sms1)[1] <- names(c)[1]

#REVISAR A PARTIR DE AQUI

##### CRUCE MASIVOS vs CUENTAS ####
#primero cruzamos las cuentas con los blasters
#c2 = cuentas.con.masivos
c2 <- left_join(c,b1.1,by="IDPRINCIPAL")
View(c2,title = "Cuentas bbva con blasters ene-junio 21")
dim(c2)

#CUENTAS CON BLASTERS, LE PEGAMOS LOS SMS
c3 <- left_join(c2,sms1,by="IDPRINCIPAL")
View(c3,title = "Cuentas bbva con blasters y sms ene-junio 21")
dim(c3)#bien unidos i=528,033 j=22

#agrupamos por RFC y obtenemos los datos de su contacto en ambos masivos
c3 <- c3 %>% group_by(RFC)%>%
  summarize(BLASTERS_ENVIADOS = sum(BLASTERS_ENVIADOS),
            BLASTERS_EXITOS =sum(BLASTERS_EXITOS),
            BLASTERS_CONTACTO=ifelse(BLASTERS_EXITOS==0,0,1),
            SMS_ENVIADOS = sum(SMS_ENVIADOS),
            SMS_EXITOS = sum(SMS_EXITOS),
            SMS_CONTACTO=ifelse(SMS_EXITOS==0,0,1)) %>% 
  mutate(CONTACTO_AMBOS_MASIVOS=ifelse(BLASTERS_EXITOS>=1 & SMS_EXITOS>=1,1,0))
View(c3);dim(c3)


# REVISAR SI ES UTIL ------------------------------------------------------
#UNION FINAL
class(c4$RFC);length(c4$RFC)
class(c$RFC);length(c$RFC)

?inner_join
view(c4)
c5 <- left_join(x =c4 ,y =c3, by="RFC")
dim(c4);dim(c5)
View(c5)
names(c5)

#OCUPANDO VLOOK UP
View(c)
?vlookup
c6 <- vlookup(lookup_value = c4$RFC ,dict =c , result_column = "PRIMER_NOMBRE",
              lookup_column = 3)
View(c6)
class(c6)
length(c6)
sum(is.na(c6))
c6 <- as.data.table(c6)


##### cruce final ####
d6.2 <- d6 %>% select(IDPRINCIPAL,RFC,HOMOCLAVE_RFC,PRIMER_NOMBRE,SEGUNDO_NOMBRE,
                      APELLIDO_PATERNO,APELLIDO_MATERNO,CODIGO_POSTAL,ENTIDAD_FEDERATIVA, 
                      MUNICIPIO.ALCALDÃ.A,COLONIA,EDAD,RANGO_EDAD,SALDO_TOTAL,
                      RANGO_DEUDA,PRODUCTO,BLASTERS_ENVIADOS,BLASTERS_EXITOS,
                      BLASTER_CONTACTO,SMS_ENVIADOS,SMS_EXITOS,SMS_CONTACTO) %>%
  group_by(RFC)

dim(d6.2)
View(d6.2)

names(d6)
d6.3 <- d6 %>% select(IDPRINCIPAL,RFC,HOMOCLAVE_RFC,PRIMER_NOMBRE,SEGUNDO_NOMBRE,
                      APELLIDO_PATERNO,APELLIDO_MATERNO,CODIGO_POSTAL,ENTIDAD_FEDERATIVA, 
                      MUNICIPIO.ALCALDÃ.A,COLONIA,EDAD,RANGO_EDAD,SALDO_TOTAL,
                      RANGO_DEUDA,PRODUCTO,BLASTERS_ENVIADOS,BLASTERS_EXITOS,
                      BLASTER_CONTACTO,SMS_ENVIADOS,SMS_EXITOS,SMS_CONTACTO) %>%
  group_by(RFC) %>% summarize(BLASTERS_ENVIADOS = sum(BLASTERS_ENVIADOS),
                              BLASTERS_EXITOS =sum(BLASTERS_EXITOS),
                              BLASTERS_CONTACTO=ifelse(BLASTERS_EXITOS==0,0,1),
                              SMS_ENVIADOS = sum(SMS_ENVIADOS),
                              SMS_EXITOS = sum(SMS_EXITOS),
                              SMS_CONTACTO=ifelse(SMS_EXITOS==0,0,1)) %>% 
  mutate(AMBOS_CONTACTO=ifelse(BLASTERS_EXITOS==1 & SMS_EXITOS==1,1,0))

View(d6.3)
names(d6.3)

#d6.4 <- inner_join(x = d6.3,y =d6 ,by=c("RFC","BLASTERS_ENVIADOS","BLASTERS_EXITOS","BLASTERS_CONTACTO",
#                             "SMS_ENVIADOS","SMS_EXITOS","SMS_CONTACTO"))
?full_join
#tendria que jalar
d6.4 <- full_join(x = d6.3,y =d1.1,by=c("RFC"))
#remove(d6.4)

View(d6.4)

##### PROPORCION DE PERSONAS CONTACTADAS ####
dim(c4)
names(c4)
View(c4)

total_cuentas <- length(unique(c$RFC))
#total de personas con al menos un contacto via BLASTER:
total_contactos <- c4 %>%
  summarise(tot_blaster_contacto = sum(BLASTERS_CONTACTO, na.rm = T),
            tot_sms_contacto = sum(SMS_CONTACTO, na.rm = T),
            tot_ambos_contacto = sum(AMBOS_CONTACTO, na.rm = T)) %>% 
  mutate(por_blaster_exitoso = 100*tot_blaster_contacto/nrow(c4),
         por_sms_exitoso = 100*tot_sms_contacto/nrow(c4),
         por_ambos_exitosos = 100*tot_ambos_contacto/nrow(c4));total_contactos

View(as.data.table(total_contactos), title = "Cifras masivos y efectividad")


# REMOCION CUENTAS SIN CONTACTO -------------------------------------------
#DISCRIMINAMOS LAS CUENTAS QUE NO TUVIERON CONTACTO PARA LA SEGMENTACION
dim(c3);names(c3)
c3 <- c3 %>% select(BLASTERS_ENVIADOS,BLASTERS_EXITOS,BLASTERS_CONTACTO,
                    SMS_ENVIADOS,SMS_EXITOS,SMS_CONTACTO,CONTACTO_AMBOS_MASIVOS) %>% 
  filter(BLASTERS_CONTACTO==1 | SMS_CONTACTO==1)

c3[is.na(c3)] <- 0# quitamos los NA's
dim(c3);View(c3,title = "datos limpios para input de k-means")#sms y blasters (parte 1)


# LISTA DE OBJETOS RELEVANTES --------------------------------------
#almacenamos relevantes en una lista para tenerlos disponibles
# lor = lista de objetos relevantes

lor <- list();length(lor);names(lor)#vacia
lor[[1]] <- campos.sms;names(lor) <- "campos.sms";lor#con los campos de los sms
lor[[2]] <- campos.blasters1;names(lor)[2] <- "campos.blasters1";lor

# EXPORTACION DE DATOS -----------------------------------------------------
getwd()#"C:/Users/aaron.lopez/Documents/Bases/Segmentacion_con_medios_masivos"
export(clasificacion.blasters,"clasificacion_blasters.xlsx")
export(clasificacion.sms,"clasificacion_sms.xlsx")



# DUDAS, PENDIENTES -------------------------------------------------------

"

"

# CODIGO TRASH ------------------------------------------------------------

# vemos los tipos de datos en consola
# for (nombre in 1:length(names(sms.prueba))) {
#   cat(nombre,".-",names(sms.prueba)[nombre],"-",class(names(sms.prueba)[nombre]),"; ")
# }

#b1$fe_bien <- ymd(b1$fe_bien)#pasamos a fecha

# c6 <-c5 %>% select(RFC,BLASTERS_ENVIADOS,BLASTERS_EXITOS,BLASTERS_CONTACTO,
#              SMS_ENVIADOS,SMS_EXITOS,SMS_CONTACTO,AMBOS_CONTACTO,
#              IDPRINCIPAL,HOMOCLAVE_RFC,PRIMER_NOMBRE,SEGUNDO_NOMBRE,
#              APELLIDO_PATERNO,APELLIDO_MATERNO,CODIGO_POSTAL,
#              ENTIDAD_FEDERATIVA,MUNICIPIO_ALCALDIA,COLONIA,
#              EDAD,RANGO_EDAD,SALDO_TOTAL,RANGO_DEUDA,PRODUCTO) %>% 
#   group_by(RFC,BLASTERS_ENVIADOS,BLASTERS_EXITOS,BLASTERS_CONTACTO,
#            SMS_ENVIADOS,SMS_EXITOS,SMS_CONTACTO,AMBOS_CONTACTO,
#            IDPRINCIPAL,HOMOCLAVE_RFC,PRIMER_NOMBRE,SEGUNDO_NOMBRE,
#            APELLIDO_PATERNO,APELLIDO_MATERNO,CODIGO_POSTAL,
#            ENTIDAD_FEDERATIVA,MUNICIPIO_ALCALDIA,COLONIA,
#            EDAD,RANGO_EDAD,SALDO_TOTAL,RANGO_DEUDA,PRODUCTO) %>% 
#   summarise(sum(BLASTERS_ENVIADOS))
#   
# dim(c6)
# View(c6)

#agrupamos por RFC y sumamos las cantidades
# d6.1 <- d6 %>% select(IDPRINCIPAL,RFC,HOMOCLAVE_RFC,PRIMER_NOMBRE,SEGUNDO_NOMBRE,
#                APELLIDO_PATERNO,APELLIDO_MATERNO,CODIGO_POSTAL,ENTIDAD_FEDERATIVA, 
#                MUNICIPIO.ALCALDÃ.A,COLONIA,EDAD,RANGO_EDAD,SALDO_TOTAL,
#                RANGO_DEUDA,PRODUCTO,BLASTERS_ENVIADOS,BLASTERS_EXITOS,
#                BLASTER_CONTACTO,SMS_ENVIADOS,SMS_EXITOS,SMS_CONTACTO) %>%
#   group_by(RFC) %>% summarize(BLASTERS_ENVIADOS = sum(BLASTERS_ENVIADOS),
#                               BLASTERS_EXITOS =sum(BLASTERS_EXITOS),
# BLASTERS_CONTACTO=ifelse(BLASTERS_EXITOS==0,0,1),
#                               SMS_ENVIADOS = sum(SMS_ENVIADOS),
#                               SMS_EXITOS = sum(SMS_EXITOS),
# SMS_CONTACTO=ifelse(SMS_EXITOS==0,0,1),
# AMBOS_CONTACTO=ifelse(BLASTERS_EXITOS==1 & SMS_EXITOS==1,1,0))



#################################################### 3 ########################################################



getwd()
choose.dir()
setwd("C:/Users/aaron.lopez/Documents/R_Scripts")
getwd()

remove()

# DATOS Y BIBLIOTECAS -------------------------------------------------------------------
library(readxl)
library(openxlsx)
library(fitdistrplus)
library(dplyr)
library(ggplot2)
library(ReIns)
library(data.table)

datos <- read_xlsx("Copia_Hist_Mayo.xlsx")
datos <- as.data.frame(datos)
dim(datos)
names(datos)
class(datos)
head(datos)
prop.table(table(datos$CONVENIO_LIQUIDO_PAGO.INTENCION))*100

"Intento de contar las casillas vacías:
sum(which(is.na(datos$CONVENIO_LIQUIDO_PAGO.INTENCION)))"
View(datos$CONVENIO_LIQUIDO_PAGO.INTENCION)

# Ligas relevantes --------------------------------------------------------
#https://stackoverflow.com/questions/43230470/how-to-convert-excel-date-format-to-proper-date-in-r/62334132

# BBVA4 -------------------------------------------------------------------
"Decido analizar la cartera BBVA4 porque fue la que cobro menos, otro dato
a notar es que hay menos creditos en ese portafolio 
"
unique(datos$CARTERA)
# Cauntos creditos hay x portFOLIO
table(datos$CARTERA)
data.frame(table(datos$CARTERA)); dim(data.frame(table(datos$CARTERA)))
num.credi.cobrad.bbva4 <- data.frame(table(datos$CARTERA))[4,2]#el numero

#Comienza el análisis del portafolio
?filter
head(datos)
View(datos)

#FILTRAMOS LOS DATOS
datos_BBVAIV <- filter(datos,CARTERA == "BBVA IV")
#los creditos LQ
datos_BBVAIV_LQ <- filter(datos,CARTERA == "BBVA IV" & ESTATUS == "LQ" )
#los creditos no LQ
datos_BBVAIV_no_LQ <- filter(datos,CARTERA == "BBVA IV" & ESTATUS != "LQ" )


#analisis exploratorio
dim(datos_BBVAIV)
dim(datos_BBVAIV_LQ)
dim(datos_BBVAIV_no_LQ)

names(datos_BBVAIV)
table(datos_BBVAIV$CONVENIO_LIQUIDO_PAGO.INTENCION)
length(datos_BBVAIV$CONVENIO_LIQUIDO_PAGO.INTENCION)

#visualizamos
g1 <- ggplot(datos_BBVAIV, aes(x=convertToDate(Fecha_Pago),
                               y=Cobranza, colour=PRODUCTO)) +
        geom_line() + xlab("") + 
        ggtitle("Cobranza por producto en el portafolio BBVA IV")

g2 <- ggplot(datos_BBVAIV_LQ, aes(x=convertToDate(Fecha_Pago),
                               y=Cobranza, colour=PRODUCTO)) +
        geom_line() + xlab("") + 
        ggtitle("Cobranza LQ por producto en el portafolio BBVA IV")

g3 <- ggplot(datos_BBVAIV_no_LQ, aes(x=convertToDate(Fecha_Pago),
                               y=Cobranza, colour=PRODUCTO)) +
        geom_line() + xlab("") + 
        ggtitle("Cobranza de NO LQ por producto en el portafolio BBVA IV")
table(datos_BBVAIV_no_LQ$PRODUCTO)


"Voy a ocupar el comportamiento de la cobranza de los créditos que aún no
se liquidan al 31-05-2021, es decir discriminamos estatus 'LQ' me servirá
para determinar probabilidades y resolver preguntas tales como:
 ¿Cuál sería el monto de'COBRANZA ESPERADA'?
 ¿Cuál es la VARIANZA del pronostico con respecto a la media de la
 'COBRANZA ESPERADA'?
 ¿Cuál es la probabilidad de que el monto de la 'COBRANZA' sea 'z',
 mayor o igual a 'x' y/o
 menor a 'y'?
 
"

"Calculamos la correlacion entre el num de pagos y la cobranza.
"
plot(datos_BBVAIV_no_LQ$PAGO_NO.,datos_BBVAIV_no_LQ$Cobranza)
cor(datos_BBVAIV_no_LQ$PAGO_NO.,datos_BBVAIV_no_LQ$Cobranza)
#Observamos que conforme aumentan el numero de pagos, dismniuye el monto de la cob 

# ANALISIS EXPLORATORIO PARA AJUSTE ---------------------------------------

?hist
#Todos los status: LQ, NO LQ, CONVENIO, PAGO INTENCIÓN, etc.
hist(datos_BBVAIV$Cobranza, breaks = 500,
     main = "Distribución empírica de la cobrtanza", xlab = "$",
     ylab = "Frecuencia",col = "blue")
plotdist(datos_BBVAIV$Cobranza, histo = T, demp = T)

#LQ
plotdist(datos_BBVAIV_LQ$Cobranza, histo = T, demp = T)

#NO LQ
plotdist(datos_BBVAIV_no_LQ$Cobranza, histo = T, demp = T)

"De estos analisis notamos que un ajuste de alguna distribucion de cola larga
 hara un buen ajuste.
" 

# AJUSTES A LA COBRANZA ---------------------------------------------------
?fitdist()

#EXPONENCIAL
ajuste.exponencial.verosimilitud<-fitdist(datos_BBVAIV$Cobranza, "exp", method = c("mle"))
summary(ajuste.exponencial.verosimilitud)#FALLA
denscomp(ajuste.exponencial.verosimilitud)


ajuste.exponencial.momentos<-fitdist(datos_BBVAIV$Cobranza, "exp", method = c("mme"))
summary(ajuste.exponencial.momentos)#PARAMETRO
denscomp(ajuste.exponencial.momentos)#AJUSTE EMPIRICO vs TEORICO
#Ajustes por qqplot:
plot(qexp(ppoints(length(datos_BBVAIV$Cobranza)))[order(order(datos_BBVAIV$Cobranza))],
     datos_BBVAIV$Cobranza)
qqplot(qexp(ppoints(length(datos_BBVAIV$Cobranza))), datos_BBVAIV$Cobranza)
qqline(datos_BBVAIV$Cobranza, distribution=qexp)


ajuste.exponencial.cuantiles<-fitdist(datos_BBVAIV$Cobranza, "exp", method = c("qme"))
summary(ajuste.exponencial.cuantiles)
denscomp(ajuste.exponencial.cuantiles)

ajuste.exponencial.bondad<-fitdist(datos_BBVAIV$Cobranza, "exp", method="mge")
summary(ajuste.exponencial.bondad)
denscomp(ajuste.exponencial.bondad)

ajuste.exponencial.espaciado<-fitdist(datos_BBVAIV$Cobranza, "exp", method="mse")
summary(ajuste.exponencial.espaciado)
denscomp(ajuste.exponencial.espaciado)


#PARETO
ajuste.pareto.verosimilitud<-fitdist(datos_BBVAIV$Cobranza, "pareto", method = c("mle"))
summary(ajuste.pareto.verosimilitud)#FALLA

ajuste.pareto.momentos<-fitdist(datos_BBVAIV$Cobranza, "exp", method = c("mme"))
summary(ajuste.pareto.momentos)#jala
ParetoQQ(datos_BBVAIV$Cobranza)#ver si ajusta

ajuste.pareto.cuantiles<-fitdist(datos_BBVAIV$Cobranza, "exp", method = c("qme"))
summary(ajuste.pareto.cuantiles)#no jala

ajuste.pareto.bondad<-fitdist(datos_BBVAIV$Cobranza, "exp", method="mge")
summary(ajuste.pareto.bondad)#no jala


ajuste.pareto.espaciado<-fitdist(datos_BBVAIV$Cobranza, "exp", method="mse")
summary(ajuste.pareto.espaciado)#no jala

# FORECAST: SERIES DE TIEMPO ----------------------------------------------------------------
#Ajuste de una serie de tiempo a la 'COBRANZA' de pagos del portafolio

cobranza_BBVAIV_forec<- read_xlsx("Copia_Hist_Abril_Mayo_2021.xlsx")
class(cobranza_BBVAIV_forec)
cobranza_BBVAIV_forec <- as.data.table(cobranza_BBVAIV_forec)
dim(cobranza_BBVAIV_forec)
table(cobranza_BBVAIV_forec$MES)
names(cobranza_BBVAIV_forec)
View(cobranza_BBVAIV_forec, title = "Cobranza no ordenada de Abril y Mayo 2021 BBVA4")

"Ahora transformamos a tipo de fecha y anadimos una variable que
extraiga el mes de la fecha para agrupar por mes y preparar el forecast"
cobranza_BBVAIV_forec$Fecha_Pago <- convertToDate(cobranza_BBVAIV_forec$Fecha_Pago)
mes <- convertToDate(cobranza_BBVAIV_forec$Fecha_Pago)
mes <- format(mes, "%m")
head(mes);tail(mes);table(mes)#validamos las entradas y que no haya NA's
cobranza_BBVAIV_forec <- cbind(cobranza_BBVAIV_forec,mes)
dim(cobranza_BBVAIV_forec)
head(cobranza_BBVAIV_forec)
names(cobranza_BBVAIV_forec)

#Sumamos por dia la cobranza:

"Aqui se agrupan los pagos por dias unicos, se suman esos montos, revisamos si
si falntan datos y finalmente defino la serie de tiempo.
"
table(cobranza_BBVAIV_forec$MES)#revisamos que no haya NA's en la vari prexist

cobranza_BBVAIV_diaria_Abril <- cobranza_BBVAIV_forec %>%
        select(MES,Fecha_Pago,Cobranza) %>% 
        filter(MES=="ABRIL 2021") %>% group_by(Fecha_Pago) %>% 
        arrange(Fecha_Pago) %>% summarize(cobranza_por_dia = sum(Cobranza))

View(cobranza_BBVAIV_diaria_Abril,title = "Cobranza por dia, Abril 2021 BBVA4" )
dim(cobranza_BBVAIV_diaria_Abril)#no hubo cobranza en 3 dias (4,11,25)
#Debido a lo s datos faltantes, debo anadirlos con el valor 0

"DEFINICION DE LA SERIE DE TIEMPO a partir de 'cobranza_BBVAIV_diaria_Abril' ;
pero primero anadimos los datos faltantes previamente identificamos.
Referencia: https://estadistica-dma.ulpgc.es/cursoR4ULPGC/14-seriesTemporales.html
"

fechas_faltantes <- data.frame(Fecha_Pago = as.Date(c("2021-04-04","2021-04-11","2021-04-25")),
                               cobranza_por_dia = c(0,0,0))
View(fechas_faltantes,title = "Fechas en las que no se cobro nada")
cobranza_BBVAIV_diaria_Abril <- rbind(cobranza_BBVAIV_diaria_Abril,fechas_faltantes)

cobranza_BBVAIV_diaria_Abril <- cobranza_BBVAIV_diaria_Abril %>% 
        arrange(Fecha_Pago)#ORDENAMOS

#YA TENEMOS EL MES COMPLETO 'cobranza_BBVAIV_diaria_Abril'
View(cobranza_BBVAIV_diaria_Abril,title = "Cobranza por dia, Abril 2021 BBVA4" )

#CONSTRUCCION DE LA SERIE DE TIEMPO
#cobranza.BBVAIV.diaria.Abril <- cobranza_BBVAIV_diaria_Abril[,2]
#cobranza.BBVAIV.diaria.Abril <- as.data.table(cobranza.BBVAIV.diaria.Abril)
cobranza.BBVAIV.diaria.Abril <- cobranza_BBVAIV_diaria_Abril
?ts

#SERIE 1, perdiodicidad diaria
cob.st <-  ts(cobranza.BBVAIV.diaria.Abril, start = 1,end = 30,
              frequency = 1)#observaciones diarias del mes
time(cob.st)
plot(cob.st,main = "Cobranza BBVA4 Abril 2021", xlab="Dias",ylab="$")
grid()

#veamos algunos retrasos:
lag.plot(cob.st)
lag.plot(cob.st, lags = 1)
lag.plot(cob.st,lags = 11)#al parecer el lag 11, muestra algo de relacion
lag.plot(cob.st,lags=4,layout=c(2,2))
lag.plot(cob.st,lags=6,layout=c(3,3))

#Veamos las autocrrelaciones 
acf(cob.st)
pacf(cob.st)

#descomponemos:
head(cob.st);dim(cob.st)
plot(decompose(cob.st))
?stl
stl(cob.st,s.window="periodic")

"PENDIENTE: Al parecer si se puede ajustar pero no la puedo descomponer
porque tengo periodicidad 1, y ambas funciones me piden periodicidad>=2

"
#SERIE 2, 
View(cobranza.BBVAIV.diaria.Abril)
cob.st.2 <-  ts(cobranza.BBVAIV.diaria.Abril, start = c(2021,04),
              frequency = 30)#observaciones diarias del mes

cob.st.3 <-  ts(cobranza.BBVAIV.diaria.Abril, start = c(2021,04),
                frequency = 30)#observaciones diarias del mes

#OJO CON LAS FECHAS DE ESTE DATASET
cob.st.4 <- ts(cobranza.BBVAIV.diaria.Abril, start = as.Date('1951-03-31'),
               end = as.Date('2021-04-25'), frequency = 365)

plot(cob.st.4)
# FORECAST: REGRESION, SUAVIZADO, ETC. ------------------------------------

hist(cobranza_BBVAIV_diaria_Abril$cobranza_por_dia,breaks = 100)
plot(cobranza_BBVAIV_diaria_Abril$Fecha_Pago,cobranza_BBVAIV_diaria_Abril$cobranza_por_dia)

linearMod <- lm(cobranza_por_dia ~ Fecha_Pago, data=cobranza_BBVAIV_diaria_Abril)
plot(linearMod)
summary(linearMod)

#GRAFICA AJUSTE LINEAL
ggplot(cobranza_BBVAIV_diaria_Abril, aes(x=Fecha_Pago,y=cobranza_por_dia)) + 
        geom_point() +
        geom_smooth(method='lm', formula=y~x, se=FALSE, col='dodgerblue1') +
        theme_light()

#Cuantos pagos mayores a 150,000; RESPEUESTA: 1
length(cobranza_BBVAIV_diaria_Abril$cobranza_por_dia)
cobranza_BBVAIV_diaria_Abril$cobranza_por_dia[cobranza_BBVAIV_diaria_Abril$cobranza_por_dia>150000]

"
Mejorar la estetica
Revisar las hipotesis del modelo, entenderlas
Hacer el forecasta y evalauar para Mayo
Calcular R cuadrada y el ECM de este modelo
Preguntar si se deja ese outlier o sostener que se deba a la periodicidad
"
# DESCUENTOS --------------------------------------------------------------

#datos_BBVAIV
names(datos_BBVAIV)
table(is.na(datos_BBVAIV$QUITA))#no hay ni un solo NA

# descuentos$QUITA <- round(descuentos$QUITA,digits = 2)
 
 descuentos <- datos_BBVAIV %>%
          select(CREDITO,Cobranza,PRODUCTO,QUITA,CONVENIO_LIQUIDO_PAGO.INTENCION,
                 ESTATUS,PAGO_NO.,CARTERA) %>% 
          arrange(desc(QUITA,Cobranza))

#descuentos <- descuentos[with(descuentos),order(QUITA,Cobranza)]
#descuentos$QUITA <- order(descuentos$QUITA, decreasing = T)  
#View(descuentos)

descuentos_2 <- data.table(descuentos)
descuentos_3 <- descuentos_2[order(-QUITA,-Cobranza)]
View(descuentos_2)
View(descuentos_3)#este ya es el bueno

max(descuentos$QUITA)#solo validamos
max(descuentos$Cobranza)

plot(descuentos$QUITA,descuentos$Cobranza)
cor(descuentos$QUITA,descuentos$Cobranza)


# NOTAS, PENDIENTES & ESTRATEGIAS -------------------------------------------------------------------

#Considerar:

#ESTRATEGIA/PENDIENTE:
"
-filtrar por 'PRODUCTO'
-Cruzar los liquidados con la intensidad de blaster, sms, la maestra 
 de los clientes para generar mas insights de su informacion
"

